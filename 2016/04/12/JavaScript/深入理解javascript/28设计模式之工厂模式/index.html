<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 设计模式之工厂模式 · Hexo</title><meta name="description" content="设计模式之工厂模式 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章列表</a></li><li class="nav-list-item"><a href="https://github.com/xuhongbo" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/abstract/" target="_self" class="nav-list-link">个人简介</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">设计模式之工厂模式</h1><div class="post-info">Apr 12, 2016</div><div class="post-content"><p>与创建型模式类似，工厂模式创建对象（视为工厂里的产品）时无需指定创建对象的具体类。</p>
<p>工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。</p>
<p>这个模式十分有用，尤其是创建对象的流程赋值的时候，比如依赖于很多设置文件等。并且，你会经常在程序里看到工厂方法，用于让子类类定义需要创建的对象类型。<br><a id="more"></a></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>下面这个例子中，是应用了工厂方法对第 26 章构造函数模式代码的改进版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var Car = (function () &#123;</div><div class="line">    var Car = function (model, year, miles) &#123;</div><div class="line">        this.model = model;</div><div class="line">        this.year = year;</div><div class="line">        this.miles = miles;</div><div class="line">    &#125;;</div><div class="line">    return function (model, year, miles) &#123;</div><div class="line">        return new Car(model, year, miles);</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line">var tom = new Car(&quot;Tom&quot;, 2009, 20000);</div><div class="line">var dudu = new Car(&quot;Dudu&quot;, 2010, 5000);</div></pre></td></tr></table></figure>
<p>不好理解的话，我们再给一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var productManager = &#123;&#125;;</div><div class="line">productManager.createProductA = function () &#123;</div><div class="line">    console.log(&apos;ProductA&apos;);</div><div class="line">&#125;</div><div class="line">productManager.createProductB = function () &#123;</div><div class="line">    console.log(&apos;ProductB&apos;);</div><div class="line">&#125;      </div><div class="line">productManager.factory = function (typeType) &#123;</div><div class="line">    return new productManager[typeType];</div><div class="line">&#125;</div><div class="line">productManager.factory(&quot;createProductA&quot;);</div></pre></td></tr></table></figure>
<p>如果还不理解的话，那我们就再详细一点咯，假如我们想在网页面里插入一些元素，而这些元素类型不固定，可能是图片，也有可能是连接，甚至可能是文本，根据工厂模式的定义，我们需要定义工厂类和相应的子类，我们先来定义子类的具体实现（也就是子函数）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">var page = page || &#123;&#125;;</div><div class="line">page.dom = page.dom || &#123;&#125;;</div><div class="line">//子函数1：处理文本</div><div class="line">page.dom.Text = function () &#123;</div><div class="line">    this.insert = function (where) &#123;</div><div class="line">        var txt = document.createTextNode(this.url);</div><div class="line">        where.appendChild(txt);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line">//子函数2：处理链接</div><div class="line">page.dom.Link = function () &#123;</div><div class="line">    this.insert = function (where) &#123;</div><div class="line">        var link = document.createElement(&apos;a&apos;);</div><div class="line">        link.href = this.url;</div><div class="line">        link.appendChild(document.createTextNode(this.url));</div><div class="line">        where.appendChild(link);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line">//子函数3：处理图片</div><div class="line">page.dom.Image = function () &#123;</div><div class="line">    this.insert = function (where) &#123;</div><div class="line">        var im = document.createElement(&apos;img&apos;);</div><div class="line">        im.src = this.url;</div><div class="line">        where.appendChild(im);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>那么我们如何定义工厂处理函数呢？其实很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">page.dom.factory = function (type) &#123;</div><div class="line">    return new page.dom[type];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var o = page.dom.factory(&apos;Link&apos;);</div><div class="line">o.url = &apos;http://www.cnblogs.com&apos;;</div><div class="line">o.insert(document.body);</div></pre></td></tr></table></figure>
<p>至此，工厂模式的介绍相信大家都已经了然于心了，我就不再多叙述了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="什么时候使用工厂模式"><a href="#什么时候使用工厂模式" class="headerlink" title="什么时候使用工厂模式"></a>什么时候使用工厂模式</h3><p>以下几种情景下工厂模式特别有用：</p>
<ol>
<li>对象的构建十分复杂</li>
<li>需要依赖具体环境创建不同实例</li>
<li>处理大量具有相同属性的小对象</li>
</ol>
<h3 id="什么时候不该用工厂模式"><a href="#什么时候不该用工厂模式" class="headerlink" title="什么时候不该用工厂模式"></a>什么时候不该用工厂模式</h3><p>不滥用运用工厂模式，有时候仅仅只是给代码增加了不必要的复杂度，同时使得测试难以运行下去。</p>
<p>。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/04/13/JavaScript/深入理解javascript/27设计模式之建造者模式/" class="prev">上一篇</a><a href="/2016/04/08/JavaScript/深入理解javascript/6S.O.L.I.D 五大原则之单一职责 SRP/" class="next">下一篇</a></div><div class="copyright"><p>© 2014 - 2017 <a href="https://github.com/xuhongbo" target="_blank">xuhongbo-github</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>