<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 闭包（Closures) · Hexo</title><meta name="description" content="闭包（Closures) - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章列表</a></li><li class="nav-list-item"><a href="https://github.com/xuhongbo" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/abstract/" target="_self" class="nav-list-link">个人简介</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">闭包（Closures)</h1><div class="post-info">Mar 1, 2016</div><div class="post-content"><p>本章我们将介绍在 JavaScript 里大家经常来讨论的话题 —— 闭包（closure）。闭包其实大家都已经谈烂了。尽管如此，这里还是要试着从理论角度来讨论下闭包，看看 ECMAScript 中的闭包内部究竟是如何工作的。</p>
<p>正如在前面的文章中提到的，这些文章都是系列文章，相互之间都是有关联的。因此，为了更好的理解本文要介绍的内容，建议先去阅读第 14 章作用域链和第 12 章变量对象。<br><a id="more"></a></p>
<h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><p>在直接讨论 ECMAScript 闭包之前，还是有必要来看一下函数式编程中一些基本定义。</p>
<p>众所周知，在函数式语言中（ECMAScript也支持这种风格），函数即是数据。就比方说，函数可以赋值给变量，可以当参数传递给其他函数，还可以从函数里返回等等。这类函数有特殊的名字和结构。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>A functional argument (“Funarg”) — is an argument which value is a function.<br>函数式参数（“Funarg”） —— 是指值为函数的参数。</p>
</blockquote>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function exampleFunc(funArg) &#123;</div><div class="line">  funArg();</div><div class="line">&#125;</div><div class="line">exampleFunc(function () &#123;</div><div class="line">  alert(&apos;funArg&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上述例子中 funarg 的实际参数其实是传递给 exampleFunc 的匿名函数。</p>
<p>反过来，接受函数式参数的函数称为高阶函数（high-order function 简称：HOF）。还可以称作：函数式函数或者偏数理或操作符。上述例子中，exampleFunc 就是这样的函数。</p>
<p>此前提到的，函数不仅可以作为参数，还可以作为返回值。这类以函数为返回值的函数称为带函数值的函数（functions with functional value or function valued functions）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(function functionValued() &#123;</div><div class="line">  return function () &#123;</div><div class="line">    alert(&apos;returned function is called&apos;);</div><div class="line">  &#125;;</div><div class="line">&#125;)()();</div></pre></td></tr></table></figure>
<p>可以以正常数据形式存在的函数（比方说：当参数传递，接受函数式参数或者以函数值返回）都称作 第一类函数（一般说第一类对象）。在 ECMAScript 中，所有的函数都是第一类对象。</p>
<p><em>函数可以作为正常数据存在（例如：当参数传递，接受函数式参数或者以函数值返回）都称作第一类函数（一般说第一类对象）。</em></p>
<p>在 ECMAScript 中，所有的函数都是第一类对象。</p>
<p>接受自己作为参数的函数，称为自应用函数（auto-applicative function 或者 self-applicative function）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(function selfApplicative(funArg) &#123;</div><div class="line">  if (funArg &amp;&amp; funArg === selfApplicative) &#123;</div><div class="line">    alert(&apos;self-applicative&apos;);</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">  selfApplicative(selfApplicative);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>以自己为返回值的函数称为自复制函数（auto-replicative function 或者 self-replicative function）。通常，“自复制”这个词用在文学作品中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function selfReplicative() &#123;</div><div class="line">  return selfReplicative;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>自复制函数的其中一个比较有意思的模式是让仅接受集合的一个项作为参数来接受从而代替接受集合本身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 接受集合的函数</div><div class="line">function registerModes(modes) &#123;</div><div class="line">  modes.forEach(registerMode, modes);</div><div class="line">&#125;</div><div class="line">// 用法</div><div class="line">registerModes([&apos;roster&apos;, &apos;accounts&apos;, &apos;groups&apos;]);</div><div class="line">// 自复制函数的声明</div><div class="line">function modes(mode) &#123;</div><div class="line">  registerMode(mode); // 注册一个mode</div><div class="line">  return modes; // 返回函数自身</div><div class="line">&#125;</div><div class="line">// 用法，modes链式调用</div><div class="line">modes(&apos;roster&apos;)(&apos;accounts&apos;)(&apos;groups&apos;)</div><div class="line">//有点类似：jQueryObject.addClass(&quot;a&quot;).toggle().removClass(&quot;b&quot;)</div></pre></td></tr></table></figure>
<p>但直接传集合用起来相对来说，比较有效并且直观。</p>
<p>在函数式参数中定义的变量，在“funarg”激活时就能够访问了（因为存储上下文数据的变量对象每次在进入上下文的时候就创建出来了）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function testFn(funArg) &#123;</div><div class="line">  // funarg激活时, 局部变量localVar可以访问了</div><div class="line">  funArg(10); // 20</div><div class="line">  funArg(20); // 30</div><div class="line">&#125;</div><div class="line">testFn(function (arg) &#123;</div><div class="line">  var localVar = 10;</div><div class="line">  alert(arg + localVar);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>然而，我们从第 14 章知道，在 ECMAScript 中，函数是可以封装在父函数中的，并可以使用父函数上下文的变量。这个特性会引发 funarg 问题。</p>
<h3 id="Funarg-问题"><a href="#Funarg-问题" class="headerlink" title="Funarg 问题"></a>Funarg 问题</h3><p>在<a href="https://en.wikipedia.org/wiki/Stack-oriented_programming_language" target="_blank" rel="external">面向堆栈的编程语言</a>中，函数的局部变量都是保存在栈上的，每当函数激活的时候，这些变量和函数参数都会压入到该堆栈上。</p>
<p>当函数返回的时候，这些参数又会从栈中移除。这种模型对将函数作为函数式值使用的时候有很大的限制（比方说，作为返回值从父函数中返回）。绝大部分情况下，问题会出现在当函数有自由变量的时候。</p>
<p><em>自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量</em></p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function testFn() &#123;</div><div class="line">  var localVar = 10;</div><div class="line">  function innerFn(innerParam) &#123;</div><div class="line">    alert(innerParam + localVar);</div><div class="line">  &#125;</div><div class="line">  return innerFn;</div><div class="line">&#125;</div><div class="line">var someFn = testFn();</div><div class="line">someFn(20); // 30</div></pre></td></tr></table></figure>
<p>上述例子中，对于 innerFn 函数来说，localVar 就属于自由变量。</p>
<p>对于采用面向栈模型来存储局部变量的系统而言，就意味着当 testFn 函数调用结束后，其局部变量都会从堆栈中移除。这样一来，当从外部对 innerFn 进行函数调用的时候，就会发生错误（因为 localVar 变量已经不存在了）。</p>
<p>而且，上述例子在面向栈实现模型中，要想将 innerFn 以返回值返回根本是不可能的。因为它也是 testFn 函数的局部变量，也会随着 testFn 的返回而移除。</p>
<p>还有一个问题是当系统采用动态作用域，函数作为函数参数使用的时候有关。</p>
<p>看如下例子（伪代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var z = 10;</div><div class="line">function foo() &#123;</div><div class="line">  alert(z);</div><div class="line">&#125;</div><div class="line">foo(); // 10 – 使用静态和动态作用域的时候</div><div class="line">(function () &#123;</div><div class="line">  var z = 20;</div><div class="line">  foo(); // 10 – 使用静态作用域, 20 – 使用动态作用域</div><div class="line">&#125;)();</div><div class="line">// 将foo作为参数的时候是一样的</div><div class="line">(function (funArg) &#123;</div><div class="line">  var z = 30;</div><div class="line">  funArg(); // 10 – 静态作用域, 30 – 动态作用域</div><div class="line">&#125;)(foo);</div></pre></td></tr></table></figure>
<p>我们看到，采用动态作用域，变量（标识符）的系统是通过变量动态栈来管理的。因此，自由变量是在当前活跃的动态链中查询的，而不是在函数创建的时候保存起来的静态作用域链中查询的。</p>
<p>这样就会产生冲突。比方说，即使Z仍然存在（与之前从栈中移除变量的例子相反），还是会有这样一个问题： 在不同的函数调用中，Z 的值到底取哪个呢（从哪个上下文，哪个作用域中查询）？</p>
<p>上述描述的就是两类 funarg 问题 —— 取决于是否将函数以返回值返回（第一类问题）以及是否将函数当函数参数使用（第二类问题）。</p>
<p>为了解决上述问题，就引入了 闭包的概念。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote>
<p>闭包是代码块和创建该代码块的上下文中数据的结合。</p>
</blockquote>
<p>让我们来看下面这个例子（伪代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var x = 20;</div><div class="line">function foo() &#123;</div><div class="line">  alert(x); // 自由变量&quot;x&quot; == 20</div><div class="line">&#125;</div><div class="line">// 为foo闭包</div><div class="line">fooClosure = &#123;</div><div class="line">  call: foo // 引用到function</div><div class="line">  lexicalEnvironment: &#123;x: 20&#125; // 搜索上下文的上下文</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上述例子中，“fooClosure”部分是伪代码。对应的，在 ECMAScript 中，“foo”函数已经有了一个内部属性——创建该函数上下文的作用域链。</p>
<p>“lexical”通常是省略的。上述例子中是为了强调在闭包创建的同时，上下文的数据就会保存起来。当下次调用该函数的时候，自由变量就可以在保存的（闭包）上下文中找到了，正如上述代码所示，变量“z”的值总是 10。</p>
<p>定义中我们使用的比较广义的词 —— “代码块”，然而，通常（在 ECMAScript 中）会使用我们经常用到的函数。当然了，并不是所有对闭包的实现都会将闭包和函数绑在一起，比方说，在 Ruby 语言中，闭包就有可能是： 一个过程对象（procedure object），一个 lambda 表达式或者是代码块。</p>
<p>对于要实现将局部变量在上下文销毁后仍然保存下来，基于栈的实现显然是不适用的（因为与基于栈的结构相矛盾）。因此在这种情况下，上层作用域的闭包数据是通过 动态分配内存的方式来实现的（基于“堆”的实现），配合使用垃圾回收器（garbage collector 简称 GC）和 引用计数（reference counting）。这种实现方式比基于栈的实现性能要低，然而，任何一种实现总是可以优化的： 可以分析函数是否使用了自由变量，函数式参数或者函数式值，然后根据情况来决定 —— 是将数据存放在堆栈中还是堆中。</p>
<h2 id="ECMAScript闭包的实现"><a href="#ECMAScript闭包的实现" class="headerlink" title="ECMAScript闭包的实现"></a>ECMAScript闭包的实现</h2><p>讨论完理论部分，接下来让我们来介绍下 ECMAScript 中闭包究竟是如何实现的。这里还是有必要再次强调下：ECMAScript 只使用静态（词法）作用域（而诸如 Perl 这样的语言，既可以使用静态作用域也可以使用动态作用域进行变量声明）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var x = 10;</div><div class="line">function foo() &#123;</div><div class="line">  alert(x);</div><div class="line">&#125;</div><div class="line">(function (funArg) &#123;</div><div class="line">  var x = 20;</div><div class="line">  // 变量&quot;x&quot;在(lexical)上下文中静态保存的，在该函数创建的时候就保存了</div><div class="line">  funArg(); // 10, 而不是20</div><div class="line">&#125;)(foo);</div></pre></td></tr></table></figure>
<p>技术上说，创建该函数的父级上下文的数据是保存在函数的内部属性 [[Scope]]中的。如果你还不了解什么是[[Scope]]，建议你先阅读第 14 章, 该章节对[[Scope]]作了非常详细的介绍。如果你对[[Scope]]和作用域链的知识完全理解了的话，那对闭包也就完全理解了。</p>
<p>根据函数创建的算法，我们看到在 ECMAScript 中，所有的函数都是闭包，因为它们都是在创建的时候就保存了上层上下文的作用域链（除开异常的情况） （不管这个函数后续是否会激活 —— [[Scope]]在函数创建的时候就有了）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var x = 10;</div><div class="line">function foo() &#123;</div><div class="line">  alert(x);</div><div class="line">&#125;</div><div class="line">// foo是闭包</div><div class="line">foo: &lt;FunctionObject&gt; = &#123;</div><div class="line">  [[Call]]: &lt;code block of foo&gt;,</div><div class="line">  [[Scope]]: [</div><div class="line">    global: &#123;</div><div class="line">      x: 10</div><div class="line">    &#125;</div><div class="line">  ],</div><div class="line">  ... // 其它属性</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如我们所说，为了优化目的，当一个函数没有使用自由变量的话，实现可能不保存在副作用域链里。不过，在 ECMA-262-3 规范里任何都没说。因此，正常来说，所有的参数都是在创建阶段保存在[[Scope]]属性里的。</p>
<p>有些实现中，允许对闭包作用域直接进行访问。比如 Rhino，针对函数的[[Scope]]属性，对应有一个非标准的<strong>parent</strong>属性，在第 12 章中作过介绍：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var global = this;</div><div class="line">var x = 10;</div><div class="line">var foo = (function () &#123;</div><div class="line">  var y = 20;</div><div class="line">  return function () &#123;</div><div class="line">    alert(y);</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div><div class="line">foo(); // 20</div><div class="line">alert(foo.__parent__.y); // 20</div><div class="line">foo.__parent__.y = 30;</div><div class="line">foo(); // 30</div><div class="line">// 可以通过作用域链移动到顶部</div><div class="line">alert(foo.__parent__.__parent__ === global); // true</div><div class="line">alert(foo.__parent__.__parent__.x); // 10</div></pre></td></tr></table></figure>
<h2 id="所有对象都引用一个-Scope"><a href="#所有对象都引用一个-Scope" class="headerlink" title="所有对象都引用一个[[Scope]]"></a>所有对象都引用一个[[Scope]]</h2><p>这里还要注意的是：在 ECMAScript 中，同一个父上下文中创建的闭包是共用一个[[Scope]]属性的。也就是说，某个闭包对其中[[Scope]]的变量做修改会影响到其他闭包对其变量的读取：</p>
<p><em>这就是说：所有的内部函数都共享同一个父作用域</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var firstClosure;</div><div class="line">var secondClosure;</div><div class="line">function foo() &#123;</div><div class="line">  var x = 1;</div><div class="line">  firstClosure = function () &#123; return ++x; &#125;;</div><div class="line">  secondClosure = function () &#123; return --x; &#125;;</div><div class="line">  x = 2; // 影响 AO[&quot;x&quot;], 在2个闭包公有的[[Scope]]中</div><div class="line">  alert(firstClosure()); // 3, 通过第一个闭包的[[Scope]]</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line">alert(firstClosure()); // 4</div><div class="line">alert(secondClosure()); // 3</div></pre></td></tr></table></figure>
<p>关于这个功能有一个非常普遍的错误认识，开发人员在循环语句里创建函数（内部进行计数）的时候经常得不到预期的结果，而期望是每个函数都有自己的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var data = [];</div><div class="line">for (var k = 0; k &lt; 3; k++) &#123;</div><div class="line">  data[k] = function () &#123;</div><div class="line">    alert(k);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">data[0](); // 3, 而不是0</div><div class="line">data[1](); // 3, 而不是1</div><div class="line">data[2](); // 3, 而不是2</div></pre></td></tr></table></figure>
<p>上述例子就证明了 —— 同一个上下文中创建的闭包是共用一个[[Scope]]属性的。因此上层上下文中的变量“k”是可以很容易就被改变的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">activeContext.Scope = [</div><div class="line">  ... // 其它变量对象</div><div class="line">  &#123;data: [...], k: 3&#125; // 活动对象</div><div class="line">];</div><div class="line">data[0].[[Scope]] === Scope;</div><div class="line">data[1].[[Scope]] === Scope;</div><div class="line">data[2].[[Scope]] === Scope;</div></pre></td></tr></table></figure>
<p>这样一来，在函数激活的时候，最终使用到的k就已经变成了 3 了。如下所示，创建一个闭包就可以解决这个问题了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var data = [];</div><div class="line">for (var k = 0; k &lt; 3; k++) &#123;</div><div class="line">  data[k] = (function _helper(x) &#123;</div><div class="line">    return function () &#123;</div><div class="line">      alert(x);</div><div class="line">    &#125;;</div><div class="line">  &#125;)(k); // 传入&quot;k&quot;值</div><div class="line">&#125;</div><div class="line">// 现在结果是正确的了</div><div class="line">data[0](); // 0</div><div class="line">data[1](); // 1</div><div class="line">data[2](); // 2</div></pre></td></tr></table></figure>
<p>让我们来看看上述代码都发生了什么？函数“_helper”创建出来之后，通过传入参数“k”激活。其返回值也是个函数，该函数保存在对应的数组元素中。这种技术产生了如下效果： 在函数激活时，每次“_helper”都会创建一个新的变量对象，其中含有参数“x”，“x”的值就是传递进来的“k”的值。这样一来，返回的函数的[[Scope]]就成了如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">data[0].[[Scope]] === [</div><div class="line">  ... // 其它变量对象</div><div class="line">  父级上下文中的活动对象AO: &#123;data: [...], k: 3&#125;,</div><div class="line">  _helper上下文中的活动对象AO: &#123;x: 0&#125;</div><div class="line">];</div><div class="line">data[1].[[Scope]] === [</div><div class="line">  ... // 其它变量对象</div><div class="line">  父级上下文中的活动对象AO: &#123;data: [...], k: 3&#125;,</div><div class="line">  _helper上下文中的活动对象AO: &#123;x: 1&#125;</div><div class="line">];</div><div class="line">data[2].[[Scope]] === [</div><div class="line">  ... // 其它变量对象</div><div class="line">  父级上下文中的活动对象AO: &#123;data: [...], k: 3&#125;,</div><div class="line">  _helper上下文中的活动对象AO: &#123;x: 2&#125;</div><div class="line">];</div></pre></td></tr></table></figure>
<p>我们看到，这时函数的[[Scope]]属性就有了真正想要的值了，为了达到这样的目的，我们不得不在[[Scope]]中创建额外的变量对象。要注意的是，在返回的函数中，如果要获取“k”的值，那么该值还是会是 3。</p>
<p>顺便提下，大量介绍 JavaScript 的文章都认为只有额外创建的函数才是闭包，这种说法是错误的。实践得出，这种方式是最有效的，然而，从理论角度来说，在 ECMAScript 中所有的函数都是闭包。</p>
<p>然而，上述提到的方法并不是唯一的方法。通过其他方式也可以获得正确的“k”的值，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var data = [];</div><div class="line">for (var k = 0; k &lt; 3; k++) &#123;</div><div class="line">  (data[k] = function () &#123;</div><div class="line">    alert(arguments.callee.x);</div><div class="line">  &#125;).x = k; // 将k作为函数的一个属性</div><div class="line">&#125;</div><div class="line">// 结果也是对的</div><div class="line">data[0](); // 0</div><div class="line">data[1](); // 1</div><div class="line">data[2](); // 2</div></pre></td></tr></table></figure>
<h2 id="Funarg-和-return"><a href="#Funarg-和-return" class="headerlink" title="Funarg 和 return"></a>Funarg 和 return</h2><p>另外一个特性是从闭包中返回。在 ECMAScript 中，闭包中的返回语句会将控制流返回给调用上下文（调用者）。而在其他语言中，比如，Ruby，有很多中形式的闭包，相应的处理闭包返回也都不同，下面几种方式都是可能的：可能直接返回给调用者，或者在某些情况下——直接从上下文退出。</p>
<p>ECMAScript 标准的退出行为如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function getElement() &#123;</div><div class="line">  [1, 2, 3].forEach(function (element) &#123;</div><div class="line">    if (element % 2 == 0) &#123;</div><div class="line">      // 返回给函数&quot;forEach&quot;函数</div><div class="line">      // 而不是返回给getElement函数</div><div class="line">      alert(&apos;found: &apos; + element); // found: 2</div><div class="line">      return element;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而，在 ECMAScript 中通过 try catch 可以实现如下效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var $break = &#123;&#125;;</div><div class="line">function getElement() &#123;</div><div class="line">  try &#123;</div><div class="line">    [1, 2, 3].forEach(function (element) &#123;</div><div class="line">      if (element % 2 == 0) &#123;</div><div class="line">        // // 从getElement中&quot;返回&quot;</div><div class="line">        alert(&apos;found: &apos; + element); // found: 2</div><div class="line">        $break.data = element;</div><div class="line">        throw $break;</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125; catch (e) &#123;</div><div class="line">    if (e == $break) &#123;</div><div class="line">      return $break.data;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return null;</div><div class="line">&#125;</div><div class="line">alert(getElement()); // 2</div></pre></td></tr></table></figure>
<h3 id="理论版本"><a href="#理论版本" class="headerlink" title="理论版本"></a>理论版本</h3><p>这里说明一下，开发人员经常错误将闭包简化理解成从父上下文中返回内部函数，甚至理解成只有匿名函数才能是闭包。</p>
<p>再说一下，因为作用域链，使得所有的函数都是闭包（与函数类型无关： 匿名函数，FE，NFE，FD 都是闭包）。 这里只有一类函数除外，那就是通过 Function 构造器创建的函数，因为其[[Scope]]只包含全局对象。</p>
<p>为了更好的澄清该问题，我们对 ECMAScript 中的闭包给出 2 个正确的版本定义：</p>
<p>ECMAScript 中，闭包指的是：</p>
<ol>
<li>从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</li>
<li>从实践角度：以下函数才算是闭包：<ol>
<li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li>
<li>在代码中引用了自由变量</li>
</ol>
</li>
</ol>
<h2 id="闭包用法实战"><a href="#闭包用法实战" class="headerlink" title="闭包用法实战"></a>闭包用法实战</h2><p>实际使用的时候，闭包可以创建出非常优雅的设计，允许对 funarg 上定义的多种计算方式进行定制。如下就是数组排序的例子，它接受一个排序条件函数作为参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[1, 2, 3].sort(function (a, b) &#123;</div><div class="line">  ... // 排序条件</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>同样的例子还有，数组的 map 方法是根据函数中定义的条件将原数组映射到一个新的数组中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[1, 2, 3].map(function (element) &#123;</div><div class="line">  return element * 2;</div><div class="line">&#125;); // [2, 4, 6]</div></pre></td></tr></table></figure>
<p>使用函数式参数，可以很方便的实现一个搜索方法，并且可以支持无限制的搜索条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">someCollection.find(function (element) &#123;</div><div class="line">  return element.someProperty == &apos;searchCondition&apos;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>还有应用函数，比如常见的 forEach 方法，将函数应用到每个数组元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[1, 2, 3].forEach(function (element) &#123;</div><div class="line">  if (element % 2 != 0) &#123;</div><div class="line">    alert(element);</div><div class="line">  &#125;</div><div class="line">&#125;); // 1, 3</div></pre></td></tr></table></figure>
<p>顺便提下，函数对象的 apply 和 call 方法，在函数式编程中也可以用作应用函数。 apply 和 call 已经在讨论“this”的时候介绍过了；这里，我们将它们看作是应用函数 —— 应用到参数中的函数（在 apply 中是参数列表，在 call 中是独立的参数）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function () &#123;</div><div class="line">  alert([].join.call(arguments, &apos;;&apos;)); // 1;2;3</div><div class="line">&#125;).apply(this, [1, 2, 3]);</div></pre></td></tr></table></figure>
<p>闭包还有另外一个非常重要的应用 —— 延迟调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = 10;</div><div class="line">setTimeout(function () &#123;</div><div class="line">  alert(a); // 10, after one second</div><div class="line">&#125;, 1000);</div></pre></td></tr></table></figure>
<p>还有回调函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//...</div><div class="line">var x = 10;</div><div class="line">// only for example</div><div class="line">xmlHttpRequestObject.onreadystatechange = function () &#123;</div><div class="line">  // 当数据就绪的时候，才会调用;</div><div class="line">  // 这里，不论是在哪个上下文中创建</div><div class="line">  // 此时变量“x”的值已经存在了</div><div class="line">  alert(x); // 10</div><div class="line">&#125;;</div><div class="line">//...</div></pre></td></tr></table></figure>
<p>还可以创建封装的作用域来隐藏辅助对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;&#125;;</div><div class="line">// 初始化</div><div class="line">(function (object) &#123;</div><div class="line">  var x = 10;</div><div class="line">  object.getX = function _getX() &#123;</div><div class="line">    return x;</div><div class="line">  &#125;;</div><div class="line">&#125;)(foo);</div><div class="line">alert(foo.getX()); // 获得闭包 &quot;x&quot; – 10</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了更多关于 ECMAScript-262-3 的理论知识，而我认为，这些基础的理论有助于理解 ECMAScript 中闭包的概念。</p>
<h2 id="其它参考"><a href="#其它参考" class="headerlink" title="其它参考"></a>其它参考</h2><ol>
<li><a href="http://jibbering.com/faq/notes/closures/" target="_blank" rel="external">Javascript Closures (by Richard Cornford)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Funarg_problem" target="_blank" rel="external">Funarg problem</a></li>
<li><a href="https://en.wikipedia.org/wiki/Closure_(computer_programming" target="_blank" rel="external">Closures</a>)</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2016/03/07/JavaScript/深入理解javascript/25设计模式之单例模式/" class="prev">上一篇</a><a href="/2016/02/25/JavaScript/深入理解javascript/15函数（Functions）/" class="next">下一篇</a></div><div class="copyright"><p>© 2014 - 2017 <a href="https://github.com/xuhongbo" target="_blank">xuhongbo-github</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>